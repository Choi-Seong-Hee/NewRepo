#include <stdio.h>

int main() {
	/*
	//int: 32비트(4바이트), 정수를 담는 데 쓰임
	int a = 5;
	int b = 3;

	int hap = a + b;
	int cha = a - b;
	int gop = a * a;
	int mok = a / b;
	int namuji = a % b;

	printf("%d + %d = %d\n", a, b, hap);
	printf("%d - %d = %d\n", a, b, cha);
	printf("%d * %d = %d\n", a, b, gop);
	printf("%d / %d = %d\n", a, b, mok); 
	//정수 나누기 정수 할때는 몫인 정수를 반환하자. 
	//mok은 정수이기 때문에 실수를 저장 할 수 없다.. 그냥 약속을 했다. 
	//정수 나누기 정수를 할 때는 그 몫을 반환을 하자.
	printf("%d %% %d = %d\n", a, b, namuji);
	
	//퍼센트를 쓰고 싶을땐 퍼센트 2개를 쓴다. > 특수문자로 간주
	*/

	// /* */ 는 사이에 오는 전체가 주석처리가 된다.
	// ctrl + h 는 변환 기능이 있다. 
	

	//float: 32비트(4바이트), 실수를 담는 데 쓰임
	float a = 5;
	float b = 3;

	float hap = a + b;
	float cha = a - b;
	float gop = a * a;
	float mok = a / b;
	

	printf("%f + %f = %f\n", a, b, hap);
	printf("%f - %f = %f\n", a, b, cha);
	printf("%f * %f = %f\n", a, b, gop);
	printf("%f / %f = %f\n", a, b, mok);
	
	/*
	
	float 는 5 / 3은 1.666666으로 뜬다.float는 실수를 담는 함수니까!소수점 까지 다 저장이 된다.
	float 용량이 작아서 오차가 발생한다. 따라서, 요즘은 double(저장공간2배)이라는 자료형을 많이 쓴다.
	저장공간이 2배 늘어나면 표현가능한 숫자의 개수는 제곱이 된다.
	위랑 결과는 똑같다. 
	float 은 부동소수점

	
	8비트 = 1바이트
	바이트 = 컴퓨터에서 데이터를 처리하는 가장 작은 단위
	자료형에는 정수형, 실수형이 있다.
	
	
	<정수형>
	 char (1바이트)
	 short(2바이트)
	 long(4바이트): -2^31 ~ 2^31 -1 사이의 개수는 2^32개 이다. 
	 -2147483648 ~ +2147483647
	 long long(8바이트)
	 int(4바이트) 원래는 시스템에 따라서 자동설정되나 요즘은 4바이트 (long)으로 결정된다.

	 <실수형>
	 float(4바이트)
	 dopuble(8바이트)

	 11111111 11111111 11111111 11111111 = -1 이다.
	 맨앞의 1은 부호이다.
	 0이면 양수, 1이면 음수이다.

	 따라서,,
	 unsigned 라는 함수는 앞의 음수 양수 부호를 무시하겠다 라는 의미이다.
	 따라서 변수를 선언할때,

	  unsigned int a; 라고 하면 
	  -2147483648 ~ +2147483647 처럼 -를 저장하지 않고,
	  0 ~ 4294967295 숫자를 쓴다. > 맨 앞 부호를 무시 (-값이 없다.)

	  unsigned double b; 처럼 실수형 변수도 마찬가지 이다.

	  마지막
	  
	  void: 리턴값이 없는 함수의 자료형

	  bool: 참, 거짓을 저장하는 자료형 
	  > 1비트만 필요한데 
	  컴퓨터에서 처리하는 가장작은 단위가 8비트여서 
	  사실상 그냥  char를 쓴는거랑 똑같다.
	  따라서 별로 필요가 없는 함수이다.

	   
	*/ 

}